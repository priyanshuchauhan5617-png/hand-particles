<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>3D Particles Smooth Version</title>
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:sans-serif;}
#ui{
position:fixed;top:10px;left:10px;z-index:10;
background:rgba(0,0,0,.6);color:#fff;padding:10px;border-radius:12px;
}
#video{
position:fixed;right:10px;bottom:10px;width:220px;height:165px;
transform:scaleX(-1);opacity:.18;border-radius:12px;
}
button{padding:6px 10px;border-radius:8px;border:none;margin-top:5px;cursor:pointer;}
</style>
</head>
<body>

<div id="ui">
<b>3D Particles (Optimized + Color Fixed)</b><br>
<button id="startBtn">Start Camera</button>
<button id="stopBtn" disabled>Stop</button>
<div id="status">Ready</div>
</div>

<video id="video" playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

<script>

/* =========================
   PERFORMANCE SETTINGS
========================= */

const PARTICLE_COUNT = 9000;
const UPDATE_CHUNK = 3;

/* =========================
   THREE SETUP
========================= */

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.01,1000);
camera.position.set(0,0,9);

const renderer = new THREE.WebGLRenderer({antialias:false,powerPreference:"high-performance"});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(1);
document.body.appendChild(renderer.domElement);

/* =========================
   PARTICLES
========================= */

const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(PARTICLE_COUNT*3);
const colors = new Float32Array(PARTICLE_COUNT*3);
const velocities = new Float32Array(PARTICLE_COUNT*3);
const targets = new Float32Array(PARTICLE_COUNT*3);

const tempColor = new THREE.Color();

for(let i=0;i<PARTICLE_COUNT;i++){
  const ix=i*3;
  positions[ix]=(Math.random()-0.5)*8;
  positions[ix+1]=(Math.random()-0.5)*8;
  positions[ix+2]=(Math.random()-0.5)*8;

  velocities[ix]=(Math.random()-0.5)*0.02;
  velocities[ix+1]=(Math.random()-0.5)*0.02;
  velocities[ix+2]=(Math.random()-0.5)*0.02;

  tempColor.setHSL(Math.random(),1,0.55);
  colors[ix]=tempColor.r;
  colors[ix+1]=tempColor.g;
  colors[ix+2]=tempColor.b;
}

geometry.setAttribute("position",new THREE.BufferAttribute(positions,3));
geometry.setAttribute("color",new THREE.BufferAttribute(colors,3));

const material = new THREE.PointsMaterial({
  size:0.02,                // smaller = no white burn
  vertexColors:true,
  transparent:true,
  opacity:0.35,             // controlled glow
  depthWrite:false,
  blending:THREE.AdditiveBlending
});

const points = new THREE.Points(geometry,material);
scene.add(points);

/* =========================
   TEMPLATES
========================= */

function heartPoint(i,N){
  const t=(i/N)*Math.PI*2;
  const x=16*Math.pow(Math.sin(t),3);
  const y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
  return {x:(x/18)*2,y:(y/18)*2,z:(Math.random()-0.5)*0.4};
}

function galaxyPoint(i,N){
  const t=i/N;
  const angle=t*Math.PI*2*8;
  const r=0.3+3*Math.sqrt(t);
  return {
    x:Math.cos(angle)*r,
    y:(Math.random()-0.5)*1.2*(1-t),
    z:Math.sin(angle)*r
  };
}

function spiralPoint(i,N){
  const t=i/N;
  const angle=t*Math.PI*2*10;
  const r=0.7+2.5*t;
  return {
    x:Math.cos(angle)*r,
    y:(t-0.5)*4,
    z:Math.sin(angle)*r
  };
}

const templates={
  hearts:heartPoint,
  galaxy:galaxyPoint,
  spiral:spiralPoint
};

let currentTemplate="hearts";
let spread=1;
let attraction=0.08;
let jitter=0.006;

function rebuildTargets(name){
  const fn=templates[name];
  for(let i=0;i<PARTICLE_COUNT;i++){
    const p=fn(i,PARTICLE_COUNT);
    const ix=i*3;
    targets[ix]=p.x*spread;
    targets[ix+1]=p.y*spread;
    targets[ix+2]=p.z*spread;
  }
}

rebuildTargets(currentTemplate);

/* =========================
   ANIMATION
========================= */

let frame=0;
const clock=new THREE.Clock();

function animate(){
  requestAnimationFrame(animate);
  const dt=Math.min(clock.getDelta(),0.033);

  points.rotation.y+=dt*0.08;
  points.rotation.x+=dt*0.03;

  const start=frame%UPDATE_CHUNK;

  for(let i=start;i<PARTICLE_COUNT;i+=UPDATE_CHUNK){
    const ix=i*3;

    velocities[ix]+=(targets[ix]-positions[ix])*attraction;
    velocities[ix+1]+=(targets[ix+1]-positions[ix+1])*attraction;
    velocities[ix+2]+=(targets[ix+2]-positions[ix+2])*attraction;

    velocities[ix]+=(Math.random()-0.5)*jitter;
    velocities[ix+1]+=(Math.random()-0.5)*jitter;
    velocities[ix+2]+=(Math.random()-0.5)*jitter;

    velocities[ix]*=0.92;
    velocities[ix+1]*=0.92;
    velocities[ix+2]*=0.92;

    positions[ix]+=velocities[ix];
    positions[ix+1]+=velocities[ix+1];
    positions[ix+2]+=velocities[ix+2];
  }

  geometry.attributes.position.needsUpdate=true;
  renderer.render(scene,camera);
  frame++;
}
animate();

/* =========================
   HAND TRACKING
========================= */

const videoEl=document.getElementById("video");
let cam=null;

function dist(a,b){
  const dx=a.x-b.x,dy=a.y-b.y;
  return Math.sqrt(dx*dx+dy*dy);
}

function classify(lm){
  const pinch=dist(lm[4],lm[8])<0.035;
  if(pinch)return"PINCH";

  const up=f=>lm[f].y<lm[f-2].y;
  const index=up(8),middle=up(12),ring=up(16),pinky=up(20);

  if(index&&middle&&ring&&pinky)return"PALM";
  if(!index&&!middle&&!ring&&!pinky)return"FIST";
  if(index&&!middle)return"ONE";
  if(index&&middle)return"V";
  return"UNKNOWN";
}

const hands=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
hands.setOptions({maxNumHands:1,modelComplexity:0});
hands.onResults(r=>{
  if(!r.multiHandLandmarks)return;
  const lm=r.multiHandLandmarks[0];
  const g=classify(lm);

  if(g==="PALM")currentTemplate="galaxy";
  if(g==="PINCH")currentTemplate="spiral";
  if(g==="FIST")currentTemplate="hearts";

  rebuildTargets(currentTemplate);
});

async function startCamera(){
  document.getElementById("startBtn").disabled=true;
  cam=new Camera(videoEl,{
    onFrame:async()=>{await hands.send({image:videoEl});},
    width:480,height:360
  });
  await cam.start();
  document.getElementById("stopBtn").disabled=false;
}

async function stopCamera(){
  if(cam)cam.stop();
  document.getElementById("startBtn").disabled=false;
  document.getElementById("stopBtn").disabled=true;
}

document.getElementById("startBtn").onclick=startCamera;
document.getElementById("stopBtn").onclick=stopCamera;

</script>
</body>
</html>
