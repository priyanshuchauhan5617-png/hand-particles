<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hand Gestures → Particle Templates (Three.js + MediaPipe)</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #000; font-family: system-ui, Arial; }
    #ui {
      position: fixed; top: 12px; left: 12px; z-index: 10;
      color: #fff; background: rgba(0,0,0,.55); padding: 10px 12px; border-radius: 12px;
      backdrop-filter: blur(8px); max-width: 360px;
    }
    #ui button {
      border: 0; padding: 8px 10px; border-radius: 10px; cursor: pointer;
      margin-right: 8px; margin-top: 8px;
    }
    #status { font-size: 13px; opacity: .9; margin-top: 6px; line-height: 1.35; }
    #debug { font-size: 12px; opacity: .85; margin-top: 6px; white-space: pre-wrap; }
    #video {
      position: fixed; right: 12px; bottom: 12px; width: 220px; height: 165px;
      transform: scaleX(-1);
      border-radius: 14px; opacity: 0.18; z-index: 9; object-fit: cover;
      border: 1px solid rgba(255,255,255,0.12);
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    <div><b>Hand Gestures → Particle Templates</b></div>
    <button id="startBtn">Start Camera</button>
    <button id="stopBtn" disabled>Stop</button>
    <div id="status">Not started.</div>
    <div id="debug"></div>
  </div>

  <video id="video" playsinline></video>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <!-- MediaPipe Hands (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

  <script>
    /***********************
     * THREE.JS SETUP
     ***********************/
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.07);

    const camera3D = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 1000);
    camera3D.position.set(0, 0.5, 9);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // Lights (subtle)
    const light = new THREE.DirectionalLight(0xffffff, 0.35);
    light.position.set(2, 4, 5);
    scene.add(light);

    /***********************
     * PARTICLES
     ***********************/
    const particleCount = 7000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const velocities = new Float32Array(particleCount * 3);

    // Targets (template points)
    const targets = new Float32Array(particleCount * 3);

    // Initialize random positions and colors
    const tmpColor = new THREE.Color();
    for (let i = 0; i < particleCount; i++) {
      const ix = i * 3;
      positions[ix + 0] = (Math.random() - 0.5) * 6;
      positions[ix + 1] = (Math.random() - 0.5) * 6;
      positions[ix + 2] = (Math.random() - 0.5) * 6;

      velocities[ix + 0] = (Math.random() - 0.5) * 0.02;
      velocities[ix + 1] = (Math.random() - 0.5) * 0.02;
      velocities[ix + 2] = (Math.random() - 0.5) * 0.02;

      tmpColor.setHSL(Math.random(), 1.0, 0.6);
      colors[ix + 0] = tmpColor.r;
      colors[ix + 1] = tmpColor.g;
      colors[ix + 2] = tmpColor.b;
    }

    geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
      size: 0.03,
      vertexColors: true,
      transparent: true,
      opacity: 0.95,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const points = new THREE.Points(geometry, material);
    scene.add(points);

    // Parameters controlled by gestures
    let attraction = 0.06;   // pull particles toward targets
    let jitter = 0.01;       // random motion
    let spread = 1.0;        // how "wide" template is
    let hueShift = 0.0;      // global color shift
    let explode = 0.0;       // fireworks burst strength
    let currentTemplate = "hearts";

    function setStatus(text) {
      document.getElementById("status").textContent = text;
    }

    function setDebug(text) {
      document.getElementById("debug").textContent = text;
    }

    /***********************
     * TEMPLATE POINT FUNCTIONS
     ***********************/
    function heartPoint(i, N) {
      // Classic 2D heart curve extruded a bit
      const t = (i / N) * Math.PI * 2;
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
      // normalize & scale
      return { x: (x / 18) * 2.2, y: (y / 18) * 2.2, z: (Math.random() - 0.5) * 0.35 };
    }

    function saturnPoint(i, N) {
      // Sphere + ring blend
      const t = i / N;
      const ringRatio = 0.55;
      const pickRing = (Math.random() < ringRatio);

      if (pickRing) {
        const a = Math.random() * Math.PI * 2;
        const r = 2.2 + (Math.random() - 0.5) * 0.35;
        const tilt = 0.35;
        const x = Math.cos(a) * r;
        const z = Math.sin(a) * r;
        const y = (Math.sin(a) * r) * tilt * 0.15;
        return { x, y, z };
      } else {
        // planet sphere
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2*v - 1);
        const r = 1.0 + (Math.random() - 0.5) * 0.15;
        return {
          x: r * Math.sin(phi) * Math.cos(theta),
          y: r * Math.cos(phi),
          z: r * Math.sin(phi) * Math.sin(theta),
        };
      }
    }

    function flowerPoint(i, N) {
      // Polar rose: r = cos(kθ)
      const k = 5;
      const t = (i / N) * Math.PI * 2;
      const r = Math.cos(k * t);
      const x = r * Math.cos(t) * 2.6;
      const y = r * Math.sin(t) * 2.6;
      const z = (Math.random() - 0.5) * 0.45;
      return { x, y, z };
    }

    function fireworksPoint(i, N) {
      // A sphere shell (burst)
      const u = Math.random();
      const v = Math.random();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2*v - 1);
      const r = 2.8 + (Math.random() - 0.5) * 0.2;
      return {
        x: r * Math.sin(phi) * Math.cos(theta),
        y: r * Math.cos(phi),
        z: r * Math.sin(phi) * Math.sin(theta),
      };
    }

    function galaxyPoint(i, N) {
      // Spiral galaxy
      const t = i / N;
      const turns = 7;
      const angle = t * Math.PI * 2 * turns;
      const radius = 0.2 + 3.0 * Math.sqrt(t);
      const y = (Math.random() - 0.5) * 0.7 * (1.0 - t);
      // add arm noise
      const arm = (Math.random() - 0.5) * 0.25;
      return {
        x: Math.cos(angle + arm) * radius,
        y,
        z: Math.sin(angle + arm) * radius,
      };
    }

    function spiralPoint(i, N) {
      // Helix spiral
      const t = i / N;
      const angle = t * Math.PI * 2 * 10;
      const radius = 0.5 + 2.2 * t;
      const y = (t - 0.5) * 4.0;
      return {
        x: Math.cos(angle) * radius,
        y,
        z: Math.sin(angle) * radius,
      };
    }

    const templates = {
      hearts: heartPoint,
      saturn: saturnPoint,
      flower: flowerPoint,
      fireworks: fireworksPoint,
      galaxy: galaxyPoint,
      spiral: spiralPoint,
    };

    function rebuildTargets(templateName) {
      const fn = templates[templateName] || templates.hearts;
      for (let i = 0; i < particleCount; i++) {
        const p = fn(i, particleCount);
        const ix = i * 3;
        targets[ix + 0] = p.x * spread;
        targets[ix + 1] = p.y * spread;
        targets[ix + 2] = p.z * spread;
      }
    }

    function setTemplate(name) {
      if (!templates[name]) return;
      currentTemplate = name;
      rebuildTargets(name);
      setStatus(`Template: ${name}`);
    }

    // init default target shape
    rebuildTargets(currentTemplate);

    /***********************
     * ANIMATION LOOP
     ***********************/
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.033);

      // slow scene rotation for nice look
      points.rotation.y += dt * 0.12;
      points.rotation.x += dt * 0.05;

      // update particles toward targets
      for (let i = 0; i < particleCount; i++) {
        const ix = i * 3;

        // attraction to targets
        const tx = targets[ix + 0];
        const ty = targets[ix + 1];
        const tz = targets[ix + 2];

        const px = positions[ix + 0];
        const py = positions[ix + 1];
        const pz = positions[ix + 2];

        const ax = (tx - px) * attraction;
        const ay = (ty - py) * attraction;
        const az = (tz - pz) * attraction;

        // velocity integrates
        velocities[ix + 0] += ax * dt * 60;
        velocities[ix + 1] += ay * dt * 60;
        velocities[ix + 2] += az * dt * 60;

        // jitter
        velocities[ix + 0] += (Math.random() - 0.5) * jitter;
        velocities[ix + 1] += (Math.random() - 0.5) * jitter;
        velocities[ix + 2] += (Math.random() - 0.5) * jitter;

        // fireworks burst pulse
        if (explode > 0.001) {
          velocities[ix + 0] += (px) * explode * 0.002;
          velocities[ix + 1] += (py) * explode * 0.002;
          velocities[ix + 2] += (pz) * explode * 0.002;
        }

        // damping
        velocities[ix + 0] *= 0.92;
        velocities[ix + 1] *= 0.92;
        velocities[ix + 2] *= 0.92;

        positions[ix + 0] += velocities[ix + 0];
        positions[ix + 1] += velocities[ix + 1];
        positions[ix + 2] += velocities[ix + 2];

        // color shift (gentle)
        const cix = ix;
        // adjust hue over time (approx: rotate RGB a tiny bit by lerp)
        // We'll keep it simple: modulate brightness slightly with hueShift
        const brighten = 0.6 + 0.4 * Math.sin((i * 0.0008) + hueShift);
        colors[cix + 0] = Math.min(1, colors[cix + 0] * 0.98 + brighten * 0.02);
        colors[cix + 1] = Math.min(1, colors[cix + 1] * 0.98 + brighten * 0.02);
        colors[cix + 2] = Math.min(1, colors[cix + 2] * 0.98 + brighten * 0.02);
      }

      explode *= 0.93;

      geometry.attributes.position.needsUpdate = true;
      geometry.attributes.color.needsUpdate = true;

      renderer.render(scene, camera3D);
    }

    animate();

    window.addEventListener("resize", () => {
      camera3D.aspect = window.innerWidth / window.innerHeight;
      camera3D.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    /***********************
     * MEDIAPIPE HANDS + GESTURES
     ***********************/
    const videoEl = document.getElementById("video");
    let cam = null;

    // Gesture mapping -> templates
    const gestureToTemplate = {
      PALM: "galaxy",
      FIST: "fireworks",
      ONE: "saturn",
      V: "flower",
      ROCK: "hearts",
      PINCH: "spiral",
    };

    // Cooldown + stability
    let lastSwitchTime = 0;
    const SWITCH_COOLDOWN_MS = 650;

    let gestureHistory = [];
    const HISTORY = 7;

    function dist2D(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.sqrt(dx*dx + dy*dy);
    }

    function fingerUp(lm, tip, pip) {
      // For many webcams: smaller y means higher on screen => finger up
      return lm[tip].y < lm[pip].y;
    }

    function thumbUpBasic(lm) {
      // Basic rule: thumb tip farther from thumb MCP than a threshold
      // (works okay without left/right detection)
      return dist2D(lm[4], lm[2]) > 0.06;
    }

    function getFingerState(lm) {
      const indexUp  = fingerUp(lm, 8, 6);
      const middleUp = fingerUp(lm, 12, 10);
      const ringUp   = fingerUp(lm, 16, 14);
      const pinkyUp  = fingerUp(lm, 20, 18);
      const tUp = thumbUpBasic(lm);
      return { thumbUp: tUp, indexUp, middleUp, ringUp, pinkyUp };
    }

    function classifyGesture(lm) {
      const f = getFingerState(lm);

      const pinch = dist2D(lm[4], lm[8]) < 0.035; // thumb tip to index tip close
      if (pinch) return "PINCH";

      // FIST: all down
      if (!f.thumbUp && !f.indexUp && !f.middleUp && !f.ringUp && !f.pinkyUp) return "FIST";

      // PALM: all up
      if (f.thumbUp && f.indexUp && f.middleUp && f.ringUp && f.pinkyUp) return "PALM";

      // ONE: index only
      if (!f.thumbUp && f.indexUp && !f.middleUp && !f.ringUp && !f.pinkyUp) return "ONE";

      // V: index + middle
      if (!f.thumbUp && f.indexUp && f.middleUp && !f.ringUp && !f.pinkyUp) return "V";

      // ROCK: thumb + index + pinky
      if (f.thumbUp && f.indexUp && !f.middleUp && !f.ringUp && f.pinkyUp) return "ROCK";

      return "UNKNOWN";
    }

    function stableGesture(g) {
      gestureHistory.push(g);
      if (gestureHistory.length > HISTORY) gestureHistory.shift();

      const counts = {};
      for (const x of gestureHistory) counts[x] = (counts[x] || 0) + 1;

      let best = "UNKNOWN";
      let bestCount = 0;
      for (const [k, v] of Object.entries(counts)) {
        if (v > bestCount) { best = k; bestCount = v; }
      }

      // require at least 4/7 frames consistent
      return bestCount >= 4 ? best : "UNKNOWN";
    }

    function applyGestureControls(gesture, lm) {
      // Extra dynamics based on hand openness, pinch distance etc.
      // Measure openness: average distance wrist->tips
      const wrist = lm[0];
      const tips = [lm[4], lm[8], lm[12], lm[16], lm[20]];
      let avg = 0;
      for (const t of tips) avg += dist2D(wrist, t);
      avg /= tips.length;

      // Map avg openness into spread
      spread = 0.9 + (avg * 2.0); // usually 0.9..2.3 range
      spread = Math.max(0.8, Math.min(spread, 2.7));

      // jitter & attraction feel
      attraction = 0.05 + (avg * 0.05);
      attraction = Math.max(0.04, Math.min(attraction, 0.12));

      jitter = 0.006 + (1.8 - spread) * 0.008;
      jitter = Math.max(0.003, Math.min(jitter, 0.02));

      // hue shift changes slowly while palm/v etc.
      hueShift += 0.06;

      // Fireworks: if FIST, pulse explode stronger
      if (gesture === "FIST") {
        explode = Math.min(1.0, explode + 0.08);
      }
    }

    function maybeSwitchTemplate(gesture) {
      const now = performance.now();
      const next = gestureToTemplate[gesture];
      if (!next) return;

      if (now - lastSwitchTime < SWITCH_COOLDOWN_MS) return;

      if (next !== currentTemplate) {
        setTemplate(next);
        lastSwitchTime = now;
      }
    }

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.6
    });

    hands.onResults((results) => {
      if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
        setDebug(`Gesture: (no hand)\nTemplate: ${currentTemplate}\nSpread: ${spread.toFixed(2)}  Attraction: ${attraction.toFixed(2)}  Jitter: ${jitter.toFixed(3)}`);
        return;
      }

      const lm = results.multiHandLandmarks[0];

      const gRaw = classifyGesture(lm);
      const g = stableGesture(gRaw);

      applyGestureControls(g, lm);
      if (g !== "UNKNOWN") maybeSwitchTemplate(g);

      setDebug(
        `Gesture: ${g} (raw: ${gRaw})\n` +
        `Template: ${currentTemplate}\n` +
        `Spread: ${spread.toFixed(2)}  Attraction: ${attraction.toFixed(2)}  Jitter: ${jitter.toFixed(3)}\n` +
        `Mappings: PALM→galaxy | FIST→fireworks | ONE→saturn | V→flower | ROCK→hearts | PINCH→spiral`
      );
    });

    async function startCamera() {
      setStatus("Starting camera...");
      document.getElementById("startBtn").disabled = true;

      cam = new Camera(videoEl, {
        onFrame: async () => {
          await hands.send({ image: videoEl });
        },
        width: 640,
        height: 480
      });

      await cam.start();
      setStatus(`Camera running. Template: ${currentTemplate}`);
      document.getElementById("stopBtn").disabled = false;
    }

    async function stopCamera() {
      try {
        if (cam) cam.stop();
        const stream = videoEl.srcObject;
        if (stream) {
          for (const track of stream.getTracks()) track.stop();
        }
        videoEl.srcObject = null;
      } catch (e) {}
      cam = null;

      setStatus("Stopped.");
      document.getElementById("startBtn").disabled = false;
      document.getElementById("stopBtn").disabled = true;
    }

    document.getElementById("startBtn").addEventListener("click", startCamera);
    document.getElementById("stopBtn").addEventListener("click", stopCamera);

    // Start with default template display
    setStatus(`Ready. Template: ${currentTemplate}`);
    setDebug(`Gesture: (none)\nTemplate: ${currentTemplate}\nMappings: PALM→galaxy | FIST→fireworks | ONE→saturn | V→flower | ROCK→hearts | PINCH→spiral`);
  </script>
</body>
</html>
