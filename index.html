<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Hand Gesture 3D Particles (Three.js + MediaPipe)</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000}
    #hud{
      position:fixed;left:12px;top:12px;z-index:10;
      font-family:system-ui,Segoe UI,Arial;color:#fff;
      background:rgba(0,0,0,.5);padding:10px 12px;border-radius:12px;
      max-width:420px;line-height:1.3
    }
    #hud b{color:#9cf}
    #start{
      margin-top:8px;border:none;border-radius:10px;
      background:#1a5cff;color:#fff;padding:8px 10px;cursor:pointer
    }
    #cam{
      position:fixed;right:12px;bottom:12px;width:200px;
      opacity:.12;transform:scaleX(-1);
      border-radius:10px;border:1px solid rgba(255,255,255,.15);
      z-index:2
    }
  </style>
</head>
<body>
  <div id="hud">
    <div><b>Gestures</b></div>
    <div>ü§è <b>Pinch</b> (thumb+index): expand / contract</div>
    <div>‚úã <b>Open palm</b>: switch template</div>
    <div>‚úä <b>Fist</b>: fireworks burst</div>
    <div>‚ÜîÔ∏è <b>Hand rotate</b>: color shift</div>
    <button id="start">Start Camera</button>
    <div id="status" style="margin-top:8px;opacity:.9"></div>
  </div>

  <video id="cam" playsinline muted></video>

  <!-- Three.js (non-module) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>

  <!-- MediaPipe Hands (non-module) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

  <script>
    // -------------------------
    // Helpers
    // -------------------------
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp=(a,b,t)=>a+(b-a)*t;
    function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

    const statusEl=document.getElementById("status");
    const setStatus=(t)=>statusEl.textContent=t;

    // -------------------------
    // Three.js Scene
    // -------------------------
    const renderer=new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth,innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    document.body.appendChild(renderer.domElement);

    const scene=new THREE.Scene();
    scene.fog=new THREE.Fog(0x000000, 6, 30);

    const camera3=new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.01, 200);
    camera3.position.set(0,1.2,7.5);

    scene.add(new THREE.AmbientLight(0xffffff,0.25));
    const dl=new THREE.DirectionalLight(0xffffff,0.35);
    dl.position.set(2,6,2);
    scene.add(dl);

    // -------------------------
    // Particles
    // -------------------------
    const N=16000;
    const geom=new THREE.BufferGeometry();
    const positions=new Float32Array(N*3);
    const colors=new Float32Array(N*3);
    const target=new Float32Array(N*3);
    const vel=new Float32Array(N*3);

    geom.setAttribute("position", new THREE.BufferAttribute(positions,3));
    geom.setAttribute("color", new THREE.BufferAttribute(colors,3));

    const mat=new THREE.PointsMaterial({
      size:0.05,
      vertexColors:true,
      transparent:true,
      blending:THREE.AdditiveBlending,
      depthWrite:false,
      opacity:0.95
    });

    const pts=new THREE.Points(geom,mat);
    scene.add(pts);

    // -------------------------
    // Templates
    // -------------------------
    const templates=["heart","flower","saturn","fireworks"];
    let templateIndex=0;

    function fillHeart(){
      for(let i=0;i<N;i++){
        const t=Math.random()*Math.PI*2;
        let x=16*Math.pow(Math.sin(t),3);
        let y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
        x/=18; y/=18;
        const s=Math.sqrt(Math.random());
        const z=(Math.random()-0.5)*0.6*(1-s);
        target[i*3+0]=x*s*2.2;
        target[i*3+1]=y*s*2.2+0.2;
        target[i*3+2]=z;
      }
    }

    function fillFlower(){
      for(let i=0;i<N;i++){
        const u=Math.random()*Math.PI*2;
        const v=Math.random();
        const petals=6;
        const rPetal=1.2+0.55*Math.sin(petals*u)*(0.5+0.5*Math.cos(Math.PI*v));
        const r=rPetal*(0.15+0.85*Math.pow(v,0.75));
        const x=r*Math.cos(u);
        const z=r*Math.sin(u);
        const y=1.35*(1-v)*(0.2+0.8*Math.cos(u*0.5))-0.3;
        const th=(Math.random()-0.5)*0.35*(1-v);
        target[i*3+0]=x*2.0;
        target[i*3+1]=y+th*0.35;
        target[i*3+2]=z*2.0;
      }
    }

    function fillSaturn(){
      const ringCount=Math.floor(N*0.68);
      const tilt=0.45;
      for(let i=0;i<ringCount;i++){
        const ang=Math.random()*Math.PI*2;
        const rr=lerp(1.9,3.1,Math.sqrt(Math.random()));
        const x=rr*Math.cos(ang);
        const z=rr*Math.sin(ang);
        const y=(Math.random()-0.5)*0.08;
        const yt=y*Math.cos(tilt)-z*Math.sin(tilt);
        const zt=y*Math.sin(tilt)+z*Math.cos(tilt);
        target[i*3+0]=x;
        target[i*3+1]=yt;
        target[i*3+2]=zt;
      }
      for(let i=ringCount;i<N;i++){
        const a=Math.random()*Math.PI*2;
        const b=Math.acos(lerp(-1,1,Math.random()));
        const r=1.05*Math.cbrt(Math.random());
        target[i*3+0]=r*Math.sin(b)*Math.cos(a);
        target[i*3+1]=r*Math.cos(b)+0.1;
        target[i*3+2]=r*Math.sin(b)*Math.sin(a);
      }
    }

    function fillFireworksRest(){
      for(let i=0;i<N;i++){
        const a=Math.random()*Math.PI*2;
        const b=Math.acos(lerp(-1,1,Math.random()));
        const r=0.9*Math.cbrt(Math.random());
        target[i*3+0]=r*Math.sin(b)*Math.cos(a);
        target[i*3+1]=r*Math.cos(b)+0.1;
        target[i*3+2]=r*Math.sin(b)*Math.sin(a);
      }
    }

    function fireworksBurst(strength=1.0){
      for(let i=0;i<N;i++){
        const a=Math.random()*Math.PI*2;
        const b=Math.acos(lerp(-1,1,Math.random()));
        const s=lerp(0.6,2.4,Math.random())*strength;
        vel[i*3+0]+=s*Math.sin(b)*Math.cos(a);
        vel[i*3+1]+=s*Math.cos(b);
        vel[i*3+2]+=s*Math.sin(b)*Math.sin(a);
      }
    }

    function fillTemplate(name){
      if(name==="heart") fillHeart();
      else if(name==="flower") fillFlower();
      else if(name==="saturn") fillSaturn();
      else if(name==="fireworks") fillFireworksRest();
      else fillHeart();

      for(let i=0;i<N*3;i++){
        positions[i]=target[i]+(Math.random()-0.5)*0.02;
        vel[i]*=0.2;
      }
      geom.attributes.position.needsUpdate=true;
    }

    function switchTemplate(){
      templateIndex=(templateIndex+1)%templates.length;
      fillTemplate(templates[templateIndex]);
      setStatus("Template: "+templates[templateIndex]);
    }

    fillTemplate(templates[templateIndex]);
    setStatus("Ready. Click Start Camera.");

    // -------------------------
    // Color (HSL)
    // -------------------------
    let hue=0;
    function updateColors(hShift){
      for(let i=0;i<N;i++){
        const x=positions[i*3+0], y=positions[i*3+1];
        const h=(hShift + 0.08*y + 0.03*x) % 1;
        const c=new THREE.Color();
        c.setHSL(h<0?h+1:h, 1, 0.55);
        colors[i*3+0]=c.r; colors[i*3+1]=c.g; colors[i*3+2]=c.b;
      }
      geom.attributes.color.needsUpdate=true;
    }

    // -------------------------
    // MediaPipe Hands
    // -------------------------
    const video=document.getElementById("cam");
    const startBtn=document.getElementById("start");

    let hands=null;
    let cam=null;

    // hand state
    let pinchSm=0, openSm=0, yawSm=0;
    let expansion=1, expansionSm=1;
    let latchOpen=false, latchFist=false;
    let haveHand=false;
    let handWorld=new THREE.Vector3(0,0,0);

    function screenToWorld(x01,y01){
      // mediapipe x/y in 0..1, video mirrored on screen
      const x=(1-x01)*2-1;
      const y=-(y01*2-1);
      const v=new THREE.Vector3(x,y,0.2).unproject(camera3);
      return v;
    }

    function computeSignals(lm){
      const wrist=lm[0];
      const thumb=lm[4];
      const index=lm[8];
      const middle=lm[12];
      const ring=lm[16];
      const pinky=lm[20];
      const palm=lm[9];

      const pinchD=dist2(thumb,index);
      const pinch=1 - clamp((pinchD-0.02)/0.12, 0, 1);

      const avgF=(dist2(index,wrist)+dist2(middle,wrist)+dist2(ring,wrist)+dist2(pinky,wrist))/4;
      const openness=clamp((avgF-0.18)/0.22, 0, 1);

      // simple yaw/rotate feel
      const vIx=(index.x-wrist.x), vPx=(pinky.x-wrist.x);
      const yaw=clamp((vIx - vPx)*0.9, -1, 1);

      return { pinch, openness, yaw, palm };
    }

    function onResults(results){
      if(!results.multiHandLandmarks || results.multiHandLandmarks.length===0){
        haveHand=false;
        return;
      }
      haveHand=true;
      const lm=results.multiHandLandmarks[0];
      const sig=computeSignals(lm);

      pinchSm=lerp(pinchSm, sig.pinch, 0.22);
      openSm=lerp(openSm, sig.openness, 0.18);
      yawSm=lerp(yawSm, sig.yaw, 0.15);

      // pinch -> expansion
      const targetExp=lerp(0.75, 2.2, pinchSm);
      expansionSm=lerp(expansionSm, targetExp, 0.12);
      expansion=expansionSm;

      // rotation -> hue shift
      hue = (hue + yawSm*0.006) % 1;

      // open palm -> switch template (once)
      const isOpen = openSm>0.78 && pinchSm<0.25;
      if(isOpen && !latchOpen){ latchOpen=true; switchTemplate(); }
      if(!isOpen) latchOpen=false;

      // fist -> burst (once)
      const isFist = openSm<0.28;
      if(isFist && !latchFist){ latchFist=true; fireworksBurst(1.0); }
      if(!isFist) latchFist=false;

      // palm position -> attractor
      handWorld.copy(screenToWorld(sig.palm.x, sig.palm.y));
    }

    async function startCamera(){
      // Secure context check
      if(!(location.protocol==="https:" || location.hostname==="localhost" || location.hostname==="127.0.0.1")){
        setStatus("Camera needs HTTPS. Use GitHub Pages or localhost.");
        return;
      }

      setStatus("Starting camera‚Ä¶ allow permission.");
      video.style.opacity = 0.18;

      hands=new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
      });

      hands.onResults(onResults);

      cam = new Camera(video, {
        onFrame: async () => { await hands.send({image: video}); },
        width: 1280, height: 720
      });

      await cam.start();
      setStatus("Camera running ‚úÖ Show your hand.");
      startBtn.style.display="none";
    }

    startBtn.addEventListener("click", () => {
      startCamera().catch(e=>{
        console.error(e);
        setStatus("Camera error: "+(e && e.message ? e.message : e));
      });
    });

    // -------------------------
    // Simulation
    // -------------------------
    let last=performance.now();
    function animate(){
      requestAnimationFrame(animate);
      const now=performance.now();
      const dt=Math.min(0.033, (now-last)/1000);
      last=now;

      updateColors(hue);

      const kAttract=10.0;
      const damping=0.86;

      for(let i=0;i<N;i++){
        const ix=i*3;

        // template target scaled
        const tx=target[ix+0]*expansion;
        const ty=target[ix+1]*expansion;
        const tz=target[ix+2]*expansion;

        let px=positions[ix+0], py=positions[ix+1], pz=positions[ix+2];

        // spring to template
        let fx=(tx-px)*kAttract;
        let fy=(ty-py)*kAttract;
        let fz=(tz-pz)*kAttract;

        // hand attractor
        if(haveHand){
          const dx=handWorld.x-px, dy=handWorld.y-py, dz=handWorld.z-pz;
          const d=Math.sqrt(dx*dx+dy*dy+dz*dz)+1e-4;
          const pull=1.4/(1.0+d*d*0.7);
          fx+=dx*pull; fy+=dy*pull; fz+=dz*pull;
        }

        // integrate
        vel[ix+0]=vel[ix+0]*damping + fx*dt;
        vel[ix+1]=vel[ix+1]*damping + fy*dt;
        vel[ix+2]=vel[ix+2]*damping + fz*dt;

        positions[ix+0]=px + vel[ix+0]*dt;
        positions[ix+1]=py + vel[ix+1]*dt;
        positions[ix+2]=pz + vel[ix+2]*dt;
      }

      geom.attributes.position.needsUpdate=true;
      scene.rotation.y += 0.002;

      renderer.render(scene,camera3);
    }
    animate();

    addEventListener("resize", ()=>{
      camera3.aspect=innerWidth/innerHeight;
      camera3.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight);
    });
  </script>
</body>
</html>
