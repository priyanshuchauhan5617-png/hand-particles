<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Particles + Old Gestures + New Templates</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #000; font-family: system-ui, Arial; }
    #ui {
      position: fixed; top: 12px; left: 12px; z-index: 10;
      color: #fff; background: rgba(0,0,0,.55); padding: 10px 12px; border-radius: 12px;
      backdrop-filter: blur(8px); max-width: 380px;
    }
    #ui button {
      border: 0; padding: 8px 10px; border-radius: 10px; cursor: pointer;
      margin-right: 8px; margin-top: 8px;
    }
    #status { font-size: 13px; opacity: .9; margin-top: 6px; line-height: 1.35; }
    #debug { font-size: 12px; opacity: .85; margin-top: 6px; white-space: pre-wrap; }
    #video {
      position: fixed; right: 12px; bottom: 12px; width: 240px; height: 180px;
      transform: scaleX(-1);
      border-radius: 14px; opacity: 0.18; z-index: 9; object-fit: cover;
      border: 1px solid rgba(255,255,255,0.12);
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    <div><b>3D Particles (Three.js) + Old Gestures (MediaPipe)</b></div>
    <button id="startBtn">Start Camera</button>
    <button id="stopBtn" disabled>Stop</button>
    <div id="status">Ready.</div>
    <div id="debug"></div>
  </div>

  <video id="video" playsinline></video>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <!-- MediaPipe Hands (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

  <script>
    /***********************
     * THREE SETUP
     ***********************/
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.07);

    const cam3D = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 1000);
    cam3D.position.set(0, 0.4, 9);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const light = new THREE.DirectionalLight(0xffffff, 0.35);
    light.position.set(2, 4, 5);
    scene.add(light);

    function setStatus(t) { document.getElementById("status").textContent = t; }
    function setDebug(t) { document.getElementById("debug").textContent = t; }

    /***********************
     * PARTICLES
     ***********************/
    const particleCount = 7000;

    const geometry = new THREE.BufferGeometry();
    const positions  = new Float32Array(particleCount * 3);
    const colors     = new Float32Array(particleCount * 3);
    const velocities = new Float32Array(particleCount * 3);
    const targets    = new Float32Array(particleCount * 3);

    const tmpColor = new THREE.Color();

    for (let i = 0; i < particleCount; i++) {
      const ix = i * 3;
      positions[ix + 0] = (Math.random() - 0.5) * 6;
      positions[ix + 1] = (Math.random() - 0.5) * 6;
      positions[ix + 2] = (Math.random() - 0.5) * 6;

      velocities[ix + 0] = (Math.random() - 0.5) * 0.02;
      velocities[ix + 1] = (Math.random() - 0.5) * 0.02;
      velocities[ix + 2] = (Math.random() - 0.5) * 0.02;

      tmpColor.setHSL(Math.random(), 1.0, 0.6);
      colors[ix + 0] = tmpColor.r;
      colors[ix + 1] = tmpColor.g;
      colors[ix + 2] = tmpColor.b;
    }

    geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
      size: 0.03,
      vertexColors: true,
      transparent: true,
      opacity: 0.95,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const points = new THREE.Points(geometry, material);
    scene.add(points);

    // dynamics (kept "old" style: attract to target + jitter)
    let attraction = 0.07;
    let jitter = 0.01;
    let spread = 1.0;
    let explode = 0.0;
    let hueShift = 0.0;

    let currentTemplate = "hearts";

    /***********************
     * TEMPLATE FUNCTIONS (OLD + NEW)
     ***********************/
    function heartPoint(i, N) {
      const t = (i / N) * Math.PI * 2;
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
      return { x: (x / 18) * 2.2, y: (y / 18) * 2.2, z: (Math.random() - 0.5) * 0.35 };
    }

    function saturnPoint(i, N) {
      const ringRatio = 0.55;
      const pickRing = (Math.random() < ringRatio);

      if (pickRing) {
        const a = Math.random() * Math.PI * 2;
        const r = 2.2 + (Math.random() - 0.5) * 0.35;
        const tilt = 0.35;
        return {
          x: Math.cos(a) * r,
          y: (Math.sin(a) * r) * tilt * 0.15,
          z: Math.sin(a) * r
        };
      } else {
        const u = Math.random(), v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2*v - 1);
        const r = 1.0 + (Math.random() - 0.5) * 0.15;
        return {
          x: r * Math.sin(phi) * Math.cos(theta),
          y: r * Math.cos(phi),
          z: r * Math.sin(phi) * Math.sin(theta),
        };
      }
    }

    function flowerPoint(i, N) {
      const k = 5;
      const t = (i / N) * Math.PI * 2;
      const r = Math.cos(k * t);
      return {
        x: r * Math.cos(t) * 2.6,
        y: r * Math.sin(t) * 2.6,
        z: (Math.random() - 0.5) * 0.45
      };
    }

    function fireworksPoint(i, N) {
      const u = Math.random(), v = Math.random();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2*v - 1);
      const r = 2.8 + (Math.random() - 0.5) * 0.2;
      return {
        x: r * Math.sin(phi) * Math.cos(theta),
        y: r * Math.cos(phi),
        z: r * Math.sin(phi) * Math.sin(theta),
      };
    }

    // ===== NEW TEMPLATES =====
    function galaxyPoint(i, N) {
      const t = i / N;
      const turns = 7;
      const angle = t * Math.PI * 2 * turns;
      const radius = 0.25 + 3.0 * Math.sqrt(t);
      const y = (Math.random() - 0.5) * 0.8 * (1.0 - t);
      const armNoise = (Math.random() - 0.5) * 0.25;

      return {
        x: Math.cos(angle + armNoise) * radius,
        y,
        z: Math.sin(angle + armNoise) * radius,
      };
    }

    function spiralPoint(i, N) {
      const t = i / N;
      const angle = t * Math.PI * 2 * 10;
      const radius = 0.6 + 2.4 * t;
      const y = (t - 0.5) * 4.0;

      return {
        x: Math.cos(angle) * radius,
        y,
        z: Math.sin(angle) * radius,
      };
    }

    const templates = {
      hearts: heartPoint,
      saturn: saturnPoint,
      flower: flowerPoint,
      fireworks: fireworksPoint,
      galaxy: galaxyPoint,   // NEW
      spiral: spiralPoint    // NEW
    };

    function rebuildTargets(templateName) {
      const fn = templates[templateName] || templates.hearts;
      for (let i = 0; i < particleCount; i++) {
        const p = fn(i, particleCount);
        const ix = i * 3;
        targets[ix + 0] = p.x * spread;
        targets[ix + 1] = p.y * spread;
        targets[ix + 2] = p.z * spread;
      }
    }

    function setTemplate(name) {
      if (!templates[name]) return;
      currentTemplate = name;
      rebuildTargets(name);
      setStatus(`Template: ${name}`);
    }

    rebuildTargets(currentTemplate);

    /***********************
     * ANIMATION
     ***********************/
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.033);

      points.rotation.y += dt * 0.12;
      points.rotation.x += dt * 0.05;

      for (let i = 0; i < particleCount; i++) {
        const ix = i * 3;

        const px = positions[ix + 0];
        const py = positions[ix + 1];
        const pz = positions[ix + 2];

        const tx = targets[ix + 0];
        const ty = targets[ix + 1];
        const tz = targets[ix + 2];

        // attraction force toward target
        const ax = (tx - px) * attraction;
        const ay = (ty - py) * attraction;
        const az = (tz - pz) * attraction;

        velocities[ix + 0] += ax * dt * 60;
        velocities[ix + 1] += ay * dt * 60;
        velocities[ix + 2] += az * dt * 60;

        // jitter
        velocities[ix + 0] += (Math.random() - 0.5) * jitter;
        velocities[ix + 1] += (Math.random() - 0.5) * jitter;
        velocities[ix + 2] += (Math.random() - 0.5) * jitter;

        // fireworks pulse
        if (explode > 0.001) {
          velocities[ix + 0] += px * explode * 0.002;
          velocities[ix + 1] += py * explode * 0.002;
          velocities[ix + 2] += pz * explode * 0.002;
        }

        // damping
        velocities[ix + 0] *= 0.92;
        velocities[ix + 1] *= 0.92;
        velocities[ix + 2] *= 0.92;

        // integrate
        positions[ix + 0] += velocities[ix + 0];
        positions[ix + 1] += velocities[ix + 1];
        positions[ix + 2] += velocities[ix + 2];

        // gentle color shimmer
        const brighten = 0.6 + 0.4 * Math.sin((i * 0.0008) + hueShift);
        colors[ix + 0] = Math.min(1, colors[ix + 0] * 0.98 + brighten * 0.02);
        colors[ix + 1] = Math.min(1, colors[ix + 1] * 0.98 + brighten * 0.02);
        colors[ix + 2] = Math.min(1, colors[ix + 2] * 0.98 + brighten * 0.02);
      }

      explode *= 0.93;
      hueShift += 0.03;

      geometry.attributes.position.needsUpdate = true;
      geometry.attributes.color.needsUpdate = true;

      renderer.render(scene, cam3D);
    }
    animate();

    window.addEventListener("resize", () => {
      cam3D.aspect = window.innerWidth / window.innerHeight;
      cam3D.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    /***********************
     * MEDIAPIPE HANDS + OLD GESTURES (UPDATED SWITCHING)
     ***********************/
    const videoEl = document.getElementById("video");
    let cam = null;

    // Old gestures mapped to templates (new templates included)
    const gestureToTemplate = {
      PALM: "galaxy",      // NEW template on old gesture
      PINCH: "spiral",     // NEW template on old gesture
      FIST: "fireworks",
      ONE: "saturn",
      V: "flower",
      ROCK: "hearts",
    };

    // Anti-flicker
    let lastSwitchTime = 0;
    const SWITCH_COOLDOWN_MS = 650;
    let gestureHistory = [];
    const HISTORY = 7;

    function dist2D(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.sqrt(dx*dx + dy*dy);
    }

    function fingerUp(lm, tip, pip) {
      return lm[tip].y < lm[pip].y;
    }

    function thumbUpBasic(lm) {
      return dist2D(lm[4], lm[2]) > 0.06;
    }

    function getFingerState(lm) {
      return {
        thumbUp: thumbUpBasic(lm),
        indexUp:  fingerUp(lm, 8, 6),
        middleUp: fingerUp(lm, 12, 10),
        ringUp:   fingerUp(lm, 16, 14),
        pinkyUp:  fingerUp(lm, 20, 18),
      };
    }

    function classifyGesture(lm) {
      const f = getFingerState(lm);

      // PINCH (thumb tip close to index tip)
      if (dist2D(lm[4], lm[8]) < 0.035) return "PINCH";

      // FIST
      if (!f.thumbUp && !f.indexUp && !f.middleUp && !f.ringUp && !f.pinkyUp) return "FIST";

      // PALM
      if (f.thumbUp && f.indexUp && f.middleUp && f.ringUp && f.pinkyUp) return "PALM";

      // ONE (index only)
      if (!f.thumbUp && f.indexUp && !f.middleUp && !f.ringUp && !f.pinkyUp) return "ONE";

      // V (index + middle)
      if (!f.thumbUp && f.indexUp && f.middleUp && !f.ringUp && !f.pinkyUp) return "V";

      // ROCK (thumb + index + pinky)
      if (f.thumbUp && f.indexUp && !f.middleUp && !f.ringUp && f.pinkyUp) return "ROCK";

      return "UNKNOWN";
    }

    function stableGesture(g) {
      gestureHistory.push(g);
      if (gestureHistory.length > HISTORY) gestureHistory.shift();

      const counts = {};
      for (const x of gestureHistory) counts[x] = (counts[x] || 0) + 1;

      let best = "UNKNOWN", bestCount = 0;
      for (const [k, v] of Object.entries(counts)) {
        if (v > bestCount) { best = k; bestCount = v; }
      }
      return bestCount >= 4 ? best : "UNKNOWN";
    }

    function applyHandDynamics(lm, gesture) {
      // Use openness to control spread/attraction smoothly
      const wrist = lm[0];
      const tips = [lm[4], lm[8], lm[12], lm[16], lm[20]];
      let avg = 0;
      for (const t of tips) avg += dist2D(wrist, t);
      avg /= tips.length;

      spread = 0.9 + (avg * 2.0);
      spread = Math.max(0.8, Math.min(spread, 2.7));

      attraction = 0.05 + (avg * 0.05);
      attraction = Math.max(0.04, Math.min(attraction, 0.12));

      jitter = 0.006 + (1.8 - spread) * 0.008;
      jitter = Math.max(0.003, Math.min(jitter, 0.02));

      // refresh target spacing when spread changes significantly
      // (cheap check: rebuild every few frames by small randomness)
      if (Math.random() < 0.07) rebuildTargets(currentTemplate);

      // fireworks punch
      if (gesture === "FIST") explode = Math.min(1.0, explode + 0.08);
    }

    function maybeSwitchTemplate(gesture) {
      const next = gestureToTemplate[gesture];
      if (!next) return;

      const now = performance.now();
      if (now - lastSwitchTime < SWITCH_COOLDOWN_MS) return;

      if (next !== currentTemplate) {
        setTemplate(next);
        lastSwitchTime = now;
      }
    }

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.6
    });

    hands.onResults((results) => {
      if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
        setDebug(`Gesture: (no hand)
Template: ${currentTemplate}
Mappings: PALM→galaxy | PINCH→spiral | FIST→fireworks | ONE→saturn | V→flower | ROCK→hearts`);
        return;
      }

      const lm = results.multiHandLandmarks[0];

      const raw = classifyGesture(lm);
      const g = stableGesture(raw);

      applyHandDynamics(lm, g);
      if (g !== "UNKNOWN") maybeSwitchTemplate(g);

      setDebug(`Gesture: ${g} (raw: ${raw})
Template: ${currentTemplate}
Spread: ${spread.toFixed(2)}  Attraction: ${attraction.toFixed(2)}  Jitter: ${jitter.toFixed(3)}
Mappings: PALM→galaxy | PINCH→spiral | FIST→fireworks | ONE→saturn | V→flower | ROCK→hearts`);
    });

    /***********************
     * CAMERA CONTROL
     ***********************/
    async function startCamera() {
      setStatus("Starting camera...");
      document.getElementById("startBtn").disabled = true;

      cam = new Camera(videoEl, {
        onFrame: async () => { await hands.send({ image: videoEl }); },
        width: 640,
        height: 480
      });

      await cam.start();
      setStatus(`Camera running. Template: ${currentTemplate}`);
      document.getElementById("stopBtn").disabled = false;
    }

    async function stopCamera() {
      try {
        if (cam) cam.stop();
        const stream = videoEl.srcObject;
        if (stream) for (const track of stream.getTracks()) track.stop();
        videoEl.srcObject = null;
      } catch (e) {}
      cam = null;

      setStatus("Stopped.");
      document.getElementById("startBtn").disabled = false;
      document.getElementById("stopBtn").disabled = true;
    }

    document.getElementById("startBtn").addEventListener("click", startCamera);
    document.getElementById("stopBtn").addEventListener("click", stopCamera);

    setStatus(`Ready. Template: ${currentTemplate}`);
    setDebug(`Gesture: (none)
Template: ${currentTemplate}
Mappings: PALM→galaxy | PINCH→spiral | FIST→fireworks | ONE→saturn | V→flower | ROCK→hearts`);
  </script>
</body>
</html>
