<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>3D Particles (Fixed Gestures)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:system-ui,Arial;}
  #ui{
    position:fixed;top:10px;left:10px;z-index:10;
    background:rgba(0,0,0,.6);color:#fff;padding:10px 12px;border-radius:12px;
    border:1px solid rgba(255,255,255,0.08);
    min-width: 260px;
  }
  #video{
    position:fixed;right:10px;bottom:10px;width:220px;height:165px;
    transform:scaleX(-1);opacity:.18;border-radius:12px;object-fit:cover;
    border:1px solid rgba(255,255,255,0.12);
  }
  button{padding:7px 10px;border-radius:9px;border:none;cursor:pointer;margin-top:8px;margin-right:6px;}
  #status{font-size:13px;opacity:.9;margin-top:6px;line-height:1.35;}
  #debug{font-size:12px;opacity:.85;margin-top:6px;white-space:pre-wrap;}
</style>
</head>
<body>

<div id="ui">
  <b>3D Particles (Smooth + Gestures Fixed)</b><br>
  <button id="startBtn">Start Camera</button>
  <button id="stopBtn" disabled>Stop</button>
  <div id="status">Ready.</div>
  <div id="debug"></div>
</div>

<video id="video" playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

<script>
/* =========================
   PERFORMANCE SETTINGS
========================= */
const PARTICLE_COUNT = 9000;
const UPDATE_CHUNK = 3;        // update 1/3 particles per frame
const VIDEO_W = 480, VIDEO_H = 360;

/* =========================
   UI
========================= */
const statusEl = document.getElementById("status");
const debugEl = document.getElementById("debug");
function setStatus(t){ statusEl.textContent = t; }
function setDebug(t){ debugEl.textContent = t; }

/* =========================
   THREE SETUP
========================= */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 1000);
camera.position.set(0, 0, 9);

const renderer = new THREE.WebGLRenderer({ antialias:false, powerPreference:"high-performance" });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(1);
document.body.appendChild(renderer.domElement);

/* =========================
   PARTICLES
========================= */
const geometry = new THREE.BufferGeometry();
const positions  = new Float32Array(PARTICLE_COUNT*3);
const colors     = new Float32Array(PARTICLE_COUNT*3);
const velocities = new Float32Array(PARTICLE_COUNT*3);
const targets    = new Float32Array(PARTICLE_COUNT*3);

const tempColor = new THREE.Color();

for(let i=0;i<PARTICLE_COUNT;i++){
  const ix=i*3;

  positions[ix+0]=(Math.random()-0.5)*8;
  positions[ix+1]=(Math.random()-0.5)*8;
  positions[ix+2]=(Math.random()-0.5)*8;

  velocities[ix+0]=(Math.random()-0.5)*0.02;
  velocities[ix+1]=(Math.random()-0.5)*0.02;
  velocities[ix+2]=(Math.random()-0.5)*0.02;

  tempColor.setHSL(Math.random(), 1, 0.55);
  colors[ix+0]=tempColor.r;
  colors[ix+1]=tempColor.g;
  colors[ix+2]=tempColor.b;
}

geometry.setAttribute("position", new THREE.BufferAttribute(positions,3));
geometry.setAttribute("color", new THREE.BufferAttribute(colors,3));

// Fix "all white" glow: smaller size + lower opacity
const material = new THREE.PointsMaterial({
  size: 0.02,
  vertexColors: true,
  transparent: true,
  opacity: 0.35,
  depthWrite: false,
  blending: THREE.AdditiveBlending
});

const points = new THREE.Points(geometry, material);
scene.add(points);

/* =========================
   TEMPLATES
========================= */
function heartPoint(i,N){
  const t=(i/N)*Math.PI*2;
  const x=16*Math.pow(Math.sin(t),3);
  const y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
  return { x:(x/18)*2, y:(y/18)*2, z:(Math.random()-0.5)*0.4 };
}

function galaxyPoint(i,N){
  const t=i/N;
  const angle=t*Math.PI*2*8;
  const r=0.3+3*Math.sqrt(t);
  const n=(Math.random()-0.5)*0.25;
  return {
    x: Math.cos(angle+n)*r,
    y: (Math.random()-0.5)*1.2*(1-t),
    z: Math.sin(angle+n)*r
  };
}

function spiralPoint(i,N){
  const t=i/N;
  const angle=t*Math.PI*2*10;
  const r=0.7+2.5*t;
  return {
    x: Math.cos(angle)*r,
    y: (t-0.5)*4,
    z: Math.sin(angle)*r
  };
}

const templates = { hearts: heartPoint, galaxy: galaxyPoint, spiral: spiralPoint };

let currentTemplate = "hearts";
let spread = 1.0;
let attraction = 0.08;
let jitter = 0.006;

function rebuildTargets(name){
  const fn = templates[name] || templates.hearts;
  for(let i=0;i<PARTICLE_COUNT;i++){
    const p = fn(i, PARTICLE_COUNT);
    const ix=i*3;
    targets[ix+0]=p.x*spread;
    targets[ix+1]=p.y*spread;
    targets[ix+2]=p.z*spread;
  }
}

function setTemplate(name){
  if(!templates[name]) return;
  if(name === currentTemplate) return; // IMPORTANT: don’t rebuild every frame
  currentTemplate = name;
  rebuildTargets(currentTemplate);
  setStatus(`Template: ${currentTemplate}`);
}

rebuildTargets(currentTemplate);

/* =========================
   ANIMATION
========================= */
let frame = 0;
const clock = new THREE.Clock();

function animate(){
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.033);

  points.rotation.y += dt*0.08;
  points.rotation.x += dt*0.03;

  const start = frame % UPDATE_CHUNK;

  for(let i=start;i<PARTICLE_COUNT;i+=UPDATE_CHUNK){
    const ix=i*3;

    velocities[ix+0] += (targets[ix+0]-positions[ix+0]) * attraction;
    velocities[ix+1] += (targets[ix+1]-positions[ix+1]) * attraction;
    velocities[ix+2] += (targets[ix+2]-positions[ix+2]) * attraction;

    velocities[ix+0] += (Math.random()-0.5) * jitter;
    velocities[ix+1] += (Math.random()-0.5) * jitter;
    velocities[ix+2] += (Math.random()-0.5) * jitter;

    velocities[ix+0] *= 0.92;
    velocities[ix+1] *= 0.92;
    velocities[ix+2] *= 0.92;

    positions[ix+0] += velocities[ix+0];
    positions[ix+1] += velocities[ix+1];
    positions[ix+2] += velocities[ix+2];
  }

  geometry.attributes.position.needsUpdate = true;
  renderer.render(scene, camera);
  frame++;
}
animate();

addEventListener("resize", () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(1);
});

/* =========================
   HAND TRACKING (FIXED)
========================= */
const videoEl = document.getElementById("video");
let cam = null;

function dist(a,b){
  const dx=a.x-b.x, dy=a.y-b.y;
  return Math.sqrt(dx*dx+dy*dy);
}

function fingerUp(lm, tip, pip){
  return lm[tip].y < lm[pip].y;
}

// Gesture classifier (same gestures as before)
function classify(lm){
  // PINCH (thumb tip 4, index tip 8)
  if (dist(lm[4], lm[8]) < 0.035) return "PINCH";

  const index  = fingerUp(lm, 8, 6);
  const middle = fingerUp(lm, 12, 10);
  const ring   = fingerUp(lm, 16, 14);
  const pinky  = fingerUp(lm, 20, 18);

  if (index && middle && ring && pinky) return "PALM";
  if (!index && !middle && !ring && !pinky) return "FIST";
  if (index && !middle && !ring && !pinky) return "ONE";
  if (index && middle && !ring && !pinky) return "V";

  return "UNKNOWN";
}

// Simple stability (prevents flicker)
let hist = [];
const HIST_N = 7;
function stable(g){
  hist.push(g);
  if(hist.length > HIST_N) hist.shift();
  const c = {};
  for(const x of hist) c[x] = (c[x]||0)+1;
  let best="UNKNOWN", bestCount=0;
  for(const k in c){ if(c[k] > bestCount){ best=k; bestCount=c[k]; } }
  return bestCount >= 4 ? best : "UNKNOWN";
}

// Map gestures → template
function gestureToTemplate(g){
  if (g === "PALM") return "galaxy";
  if (g === "PINCH") return "spiral";
  if (g === "FIST") return "hearts";
  return null;
}

const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 0,
  minDetectionConfidence: 0.6,
  minTrackingConfidence: 0.6
});

hands.onResults((r) => {
  // FIX: handle empty list safely
  if (!r.multiHandLandmarks || r.multiHandLandmarks.length === 0) {
    setDebug(`Gesture: (no hand)\nTemplate: ${currentTemplate}\nUse: PALM / PINCH / FIST`);
    return;
  }

  const lm = r.multiHandLandmarks[0];
  const raw = classify(lm);
  const g = stable(raw);

  const next = gestureToTemplate(g);
  if (next) setTemplate(next);

  setDebug(`Gesture: ${g} (raw: ${raw})\nTemplate: ${currentTemplate}\nGestures: PALM→galaxy | PINCH→spiral | FIST→hearts`);
});

async function startCamera(){
  setStatus("Starting camera...");
  document.getElementById("startBtn").disabled = true;

  cam = new Camera(videoEl, {
    onFrame: async () => { await hands.send({ image: videoEl }); },
    width: VIDEO_W,
    height: VIDEO_H
  });

  await cam.start();
  setStatus(`Camera running. Template: ${currentTemplate}`);
  document.getElementById("stopBtn").disabled = false;
}

async function stopCamera(){
  try{
    if(cam) cam.stop();
    const stream = videoEl.srcObject;
    if(stream) stream.getTracks().forEach(t => t.stop());
    videoEl.srcObject = null;
  }catch(e){}
  cam = null;

  setStatus("Stopped.");
  document.getElementById("startBtn").disabled = false;
  document.getElementById("stopBtn").disabled = true;
}

document.getElementById("startBtn").onclick = startCamera;
document.getElementById("stopBtn").onclick = stopCamera;

setStatus(`Ready. Template: ${currentTemplate}`);
setDebug(`Gesture: (none)\nTemplate: ${currentTemplate}\nUse: PALM / PINCH / FIST`);
</script>
</body>
</html>
